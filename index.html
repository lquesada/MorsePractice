<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <title>Morse Practice</title>
    <style>
        /* Fullscreen overlay styles */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            text-align: center;
            font-size: 2.5rem;
            z-index: 9999;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            touch-action: manipulation;
            min-height: 0;
            -ms-touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .controls {
            padding: 10px;
            background: #2a2a2a;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
            min-height: 80px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 14px;
            font-weight: bold;
        }

        .mode-buttons {
            display: flex;
            gap: 5px;
        }

        .mode-btn, .polarity-btn {
            padding: 8px 16px;
            border: 2px solid #555;
            background: #333;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .mode-btn.active, .polarity-btn.active {
            background: #007acc;
            border-color: #007acc;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            width: 100px;
            height: 25px;
            background: #555;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
        }

        .slider-thumb {
            width: 20px;
            height: 20px;
            background: #007acc;
            border-radius: 50%;
            position: absolute;
            top: 2.5px;
            transition: left 0.1s;
            cursor: pointer;
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }

        .output {
            flex: 1 1 50px; /* grow, shrink, basis */
            min-height: 50px;
            padding: 20px;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            line-height: 1.6;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .buttons {
            min-height: 200px;
            display: flex;
            background: #2a2a2a;
            user-select: none;
            touch-action: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .utility-btn {
            padding: 8px 16px;
            border: 2px solid #555;
            background: #333;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .show-table-btn {
            padding: 8px 16px;
            border: 2px solid #555;
            background: #333;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .show-table-btn.active {
            background: #007acc;
            border-color: #007acc;
        }

        .table-container {
            display: none;
            max-height: 720px;
            flex-shrink: 1;
            padding: 10px;
            background: #111;
            color: #ccc;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            border-top: 2px solid #333;
            border-bottom: 2px solid #333;
        }

        .table-container.visible {
            display: block;
        }

        .morse-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 0;
            justify-content: center;
        }

        .morse-section {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .morse-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .morse-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px;
            font-family: 'Courier New', monospace;
        }

        .morse-char {
            font-size: 15px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 2px;
        }

        .morse-code {
            font-size: 12px;
            color: #ddd;
            text-align: center;
            line-height: 1;
        }

        .paddle {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 10px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            border: none;
            background: #444;
            line-height: 1;
        }

        .paddle.left {
            background: #444;
            border-right: 2px solid #666;
        }

        .paddle.right {
            background: #555;
        }

        .paddle.single {
            background: #444;
            border-right: none;
        }

        .paddle.left:active {
            background: #444;
        }
        .paddle.right:active {
            background: #555;
        }
        .paddle.pressed {
            background: #007acc !important;
        }

        .openline {
            display: block;
            font-size: 50px;
            color: #ddaa55;
            padding: 10px;
        }

        .instructions {
            display: block;
            max-width: 500px;
            font-size: 16px;
            line-height: 20px;
            color: #dddddd;
            padding: 20px;
        }

        .credit {
            display: block;
            padding: 20px;
            font-size: 16px;
        }

        .credit a:link,
        .credit a:visited,
        .credit a:hover,
        .credit a:active {
          color: #9999ff;
          font-weight: bold;
        }

        .version {
            display: block;
            padding: 0px;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .controls {
                padding: 8px;
                min-height: 70px;
            }
            
            .control-group label {
                font-size: 12px;
            }
            
            .mode-btn, .polarity-btn {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .output {
                font-size: 28px;
                padding: 15px;
            }
        }

        @media (max-height: 1200px) {
            .table-container {
                max-height: calc(100vh - 480px) !important;
                min-height: 50px !important;
            }
        }

        @media (max-height: 400px) {
            .buttons {
                min-height: calc(100vh - 180px) !important;
            }
            .output {
                max-height: 50px !important;
                height: 50px !important;
                padding: 5px;
            }
        }

    </style>
</head>
<body>
    <div id="start-overlay">
        <div class="openline">Morse Practice</div>
        <div class="openline">[Click to Start]</div>
        <div class="instructions">Supported inputs: keyboard, touch screen, mouse, or a paddle with usb adapter.<br/><br/>For mouse only keying, leave the mouse pointer above the left app button - left clicks will trigger the left paddle, right clicks will trigger the right paddle.<br/><br/>For an USB-to-keyboard paddle adapter it works out of the box (e.g. tested with VBand) - let me know if it doesn't.<br/><br/>For an USB-to-mouse paddle adapter, leave the mouse pointer above the left app button and use the paddle key - tapping the right paddle will map to a right mouse click on the left button, which will trigger the app right button.</div>
        <div class="credit" id="credit">
            Copyright (c) 2025, Luis Quesada (HB9IPH), <a href="https://lquesada.github.io/resume">www.luisquesada.com</a>
        </div>
        <div class="version" id="version">
            version 1.20
        </div>
    </div>

        
    <div class="controls">
        <div class="control-group">
            <label>Key:</label>
            <div class="mode-buttons">
                <button class="mode-btn" data-mode="straight">Straight</button>
                <button class="mode-btn" data-mode="iambic-a">Iambic A</button>
                <button class="mode-btn" data-mode="iambic-b">Iambic B</button>
            </div>
        
        </div>
        <div class="control-group">
            <label>Dit:</label>
            <div class="mode-buttons">
                <button class="polarity-btn" data-polarity="normal">Left</button>
                <button class="polarity-btn" data-polarity="inverse">Right</button>
            </div>
        </div>

        
        <div class="control-group">
            <label>Vol:</label>
            <div class="slider-container">
                <div class="slider" id="vol-slider">
                    <div class="slider-thumb"></div>
                </div>
                <div class="slider-value" id="vol-value">15</div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Tone:</label>
            <div class="slider-container">
                <div class="slider" id="tone-slider">
                    <div class="slider-thumb"></div>
                </div>
                <div class="slider-value" id="tone-value">700</div>
            </div>
        </div>

        <div class="control-group">
            <label>WPM:</label>
            <div class="slider-container">
                <div class="slider" id="wpm-slider">
                    <div class="slider-thumb"></div>
                </div>
                <div class="slider-value" id="wpm-value">15</div>
            </div>
        </div>
        
        <div class="control-group">
            <button id="clear-output-btn" class="utility-btn">Clear</button>
        </div>

        <div class="control-group">
            <button id="show-table-btn" class="show-table-btn">Table</button>
        </div>

    </div>
    
    <div class="output" id="output"></div>
    
    <div class="table-container" id="table-container">
        <div class="morse-grid">
            <div class="morse-section">
                <div class="section-title">LETTERS</div>
                <div class="morse-item"><div class="morse-char">A</div><div class="morse-code">.-</div></div>
                <div class="morse-item"><div class="morse-char">B</div><div class="morse-code">-...</div></div>
                <div class="morse-item"><div class="morse-char">C</div><div class="morse-code">-.-.</div></div>
                <div class="morse-item"><div class="morse-char">D</div><div class="morse-code">-..</div></div>
                <div class="morse-item"><div class="morse-char">E</div><div class="morse-code">.</div></div>
                <div class="morse-item"><div class="morse-char">F</div><div class="morse-code">..-.</div></div>
                <div class="morse-item"><div class="morse-char">G</div><div class="morse-code">--.</div></div>
                <div class="morse-item"><div class="morse-char">H</div><div class="morse-code">....</div></div>
                <div class="morse-item"><div class="morse-char">I</div><div class="morse-code">..</div></div>
                <div class="morse-item"><div class="morse-char">J</div><div class="morse-code">.---</div></div>
                <div class="morse-item"><div class="morse-char">K</div><div class="morse-code">-.-</div></div>
                <div class="morse-item"><div class="morse-char">L</div><div class="morse-code">.-..</div></div>
                <div class="morse-item"><div class="morse-char">M</div><div class="morse-code">--</div></div>
                <div class="morse-item"><div class="morse-char">N</div><div class="morse-code">-.</div></div>
                <div class="morse-item"><div class="morse-char">O</div><div class="morse-code">---</div></div>
                <div class="morse-item"><div class="morse-char">P</div><div class="morse-code">.--.</div></div>
                <div class="morse-item"><div class="morse-char">Q</div><div class="morse-code">--.-</div></div>
                <div class="morse-item"><div class="morse-char">R</div><div class="morse-code">.-.</div></div>
                <div class="morse-item"><div class="morse-char">S</div><div class="morse-code">...</div></div>
                <div class="morse-item"><div class="morse-char">T</div><div class="morse-code">-</div></div>
                <div class="morse-item"><div class="morse-char">U</div><div class="morse-code">..-</div></div>
                <div class="morse-item"><div class="morse-char">V</div><div class="morse-code">...-</div></div>
                <div class="morse-item"><div class="morse-char">W</div><div class="morse-code">.--</div></div>
                <div class="morse-item"><div class="morse-char">X</div><div class="morse-code">-..-</div></div>
                <div class="morse-item"><div class="morse-char">Y</div><div class="morse-code">-.--</div></div>
                <div class="morse-item"><div class="morse-char">Z</div><div class="morse-code">.--.</div></div>
            </div>
            
            <div class="morse-section">
                <div class="section-title">NUMBERS</div>
                <div class="morse-item"><div class="morse-char">0</div><div class="morse-code">-----</div></div>
                <div class="morse-item"><div class="morse-char">1</div><div class="morse-code">.----</div></div>
                <div class="morse-item"><div class="morse-char">2</div><div class="morse-code">..---</div></div>
                <div class="morse-item"><div class="morse-char">3</div><div class="morse-code">...--</div></div>
                <div class="morse-item"><div class="morse-char">4</div><div class="morse-code">....-</div></div>
                <div class="morse-item"><div class="morse-char">5</div><div class="morse-code">.....</div></div>
                <div class="morse-item"><div class="morse-char">6</div><div class="morse-code">-....</div></div>
                <div class="morse-item"><div class="morse-char">7</div><div class="morse-code">--...</div></div>
                <div class="morse-item"><div class="morse-char">8</div><div class="morse-code">---..</div></div>
                <div class="morse-item"><div class="morse-char">9</div><div class="morse-code">----.</div></div>
            </div>
            
            <div class="morse-section">
                <div class="section-title">SYMBOLS</div>
                <div class="morse-item"><div class="morse-char">?</div><div class="morse-code">..--..</div></div>
                <div class="morse-item"><div class="morse-char">!</div><div class="morse-code">-.-.--</div></div>
                <div class="morse-item"><div class="morse-char">.</div><div class="morse-code">.-.-.-</div></div>
                <div class="morse-item"><div class="morse-char">:</div><div class="morse-code">---...</div></div>
                <div class="morse-item"><div class="morse-char">;</div><div class="morse-code">-.-.-.</div></div>
                <div class="morse-item"><div class="morse-char">=</div><div class="morse-code">-...-</div></div>
                <div class="morse-item"><div class="morse-char">/</div><div class="morse-code">-..-.</div></div>
                <div class="morse-item"><div class="morse-char">@</div><div class="morse-code">.--.-.</div></div>
                <div class="morse-item"><div class="morse-char">'</div><div class="morse-code">.----.</div></div>
                <div class="morse-item"><div class="morse-char">-</div><div class="morse-code">-....-</div></div>
                <div class="morse-item"><div class="morse-char">,</div><div class="morse-code">--.-..</div></div>
                <div class="morse-item"><div class="morse-char">"</div><div class="morse-code">.-..-.</div></div>
                <div class="morse-item"><div class="morse-char">+</div><div class="morse-code">.-.-.</div></div>
                <div class="morse-item"><div class="morse-char">(</div><div class="morse-code">-.--.</div></div>
                <div class="morse-item"><div class="morse-char">)</div><div class="morse-code">-.--.-</div></div>
            </div>
        </div>
    </div>
    
    <div class="buttons" id="buttons">
        <button class="paddle left" id="left-paddle">tap or [ or A or left arrow</button>
        <button class="paddle right" id="right-paddle">tap or ] or D or right arrow</button>
    </div>

    <script>
        // Morse code table
        const MORSE_TABLE = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..',

            '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
            '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.',

            '?': '..--..', '!': '-.-.--', '.': '.-.-.-', ':': '---...', ';': '-.-.-.',
            '=': '-...-', '/': '-..-.', '@': '.--.-.', "'": '.----.', '-': '-....-',
            ',': '--..--', '"': '.-..-.', '+': '.-.-.', '(': '-.--.', ')': '-.--.-',

            '<AR>': '.-.-.', '<AS>': '.-...', '<HH>': '........', '<SK>': '...-.-',
            //'<KN>': '-.--.',  same as '('
            
            ' ': ' '
        };

        const REVERSE_MORSE = {};
        Object.keys(MORSE_TABLE).forEach(key => {
            REVERSE_MORSE[MORSE_TABLE[key]] = key;
        });

        // Settings persistence
        function loadSettings() {
            try {
                const saved = localStorage.getItem('morseTrainerSettings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('Loaded settings:', parsed); // Debug line
                    return {
                        mode: parsed.mode || 'iambic-a',
                        wpm: parsed.wpm || 15,
                        vol: parsed.vol || 40,
                        tone: parsed.tone || 700,
                        polarity: parsed.polarity || 'normal',
                        showTable: parsed.showTable || false
                    };
                }
            } catch (e) {
                console.log('Could not load settings:', e);
            }
            console.log('Using default settings'); // Debug line
            return {
                mode: 'iambic-a',
                wpm: 15,
                vol: 40,
                tone: 700,
                polarity: 'normal',
                showTable: false
            };
        }

        function saveSettings() {
            try {
                localStorage.setItem('morseTrainerSettings', JSON.stringify(settings));
            } catch (e) {
                console.log('Could not save settings:', e);
            }
        }

        // Application state
        let settings = loadSettings();

        let morseState = {
            currentCode: '',
            lastElementTime: 0,
            isTransmitting: false,
            leftPressed: false,
            rightPressed: false,
            lastElement: '',
            elementQueue: [],
            letterTimeout: null,
            wordTimeout: null,
            elementStartTime: 0,
            iambicScheduled: false
        };


        // Audio
        let audioContext;
        let audioInitialized = false;
        let audioReady = false;
        let currentOscillator = null;
        let currentGain = null;

        function initAudio() {
            if (audioInitialized) return;
            audioInitialized = true;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioReady = true;
            } catch (e) {
                console.error("Audio init failed:", e);
                audioReady = false;
            }
        }

        function playTone(duration = null) {
            if (!audioContext || !audioReady) return;

            const now = audioContext.currentTime;

            // Create a new oscillator and gain node
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = "triangle"; 
            osc.frequency.setValueAtTime(settings.tone, now);
            gain.gain.setValueAtTime(settings.vol / 100, now);

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.start(now);

            if (duration) {
                osc.stop(now + duration / 1000);
            }

            // Store for optional manual stopping
            currentOscillator = osc;
            currentGain = gain;
        }

        function stopTone() {
            if (!audioContext || !audioReady) return;

            if (currentGain) {
                const now = audioContext.currentTime;
                currentGain.gain.cancelScheduledValues(now);
                currentGain.gain.setValueAtTime(0, now);
            }

            if (currentOscillator) {
                try {
                    currentOscillator.stop();
                } catch (e) {
                    // already stopped
                }
                currentOscillator.disconnect();
                currentOscillator = null;
                currentGain = null;
            }
        }



        // Get timing values based on WPM
        function getTimings() {
            const ditLength = 1200 / settings.wpm; // milliseconds
            return {
                dit: ditLength,
                dah: ditLength * 3,
                elementGap: ditLength,
                letterGap: ditLength * 3,
                wordGap: ditLength * 7
            };
        }

        // Output text to display
        function outputText(text) {
            const output = document.getElementById('output');
            output.textContent += text;
            output.scrollTop = output.scrollHeight;
        }

        // Process morse code and reset state
        function processMorseCode(code) {
            if (code === '') return;
            
            const char = REVERSE_MORSE[code];
            if (char !== undefined) {
                outputText(char);
            } else {
                outputText('[?]');
            }
            
            // Reset the current code after processing
            morseState.currentCode = '';
            morseState.lastElementTime = Date.now();
        }

        // Clear existing timeouts
        function clearTimingTimeouts() {
            if (morseState.letterTimeout) {
                clearTimeout(morseState.letterTimeout);
                morseState.letterTimeout = null;
            }
            if (morseState.wordTimeout) {
                clearTimeout(morseState.wordTimeout);
                morseState.wordTimeout = null;
            }
        }

        // Set up letter/word detection timeouts
        function setupLetterWordTimeouts() {
            clearTimingTimeouts();
            const timings = getTimings();
            const now = Date.now();
            
            // Letter timeout (shorter)
            morseState.letterTimeout = setTimeout(() => {
                if (morseState.currentCode && !morseState.isTransmitting) {
                    processMorseCode(morseState.currentCode);
                    // After processing letter, set up word timeout
                    morseState.wordTimeout = setTimeout(() => {
                        if (!morseState.isTransmitting && !morseState.currentCode) {
                            outputText(' ');
                        }
                    }, timings.wordGap - timings.letterGap);
                }
            }, timings.letterGap);
        }

        // Handle element timing for straight key
        function handleStraightKey(isPressed) {
            const now = Date.now();
            const timings = getTimings();
            
            if (isPressed) {
                // Clear any pending timeouts when new transmission starts
                clearTimingTimeouts();
                
                if (!morseState.isTransmitting) {
                    morseState.isTransmitting = true;
                    morseState.lastElementTime = now;
                    playTone();
                }
            } else {
                if (morseState.isTransmitting) {
                    morseState.isTransmitting = false;
                    stopTone();
                    
                    const duration = now - morseState.lastElementTime;
                    const element = duration < (timings.dit + timings.dah) / 2 ? '.' : '-';
                    morseState.currentCode += element;
                    morseState.lastElementTime = now;
                    
                    // Set up timeouts for letter/word detection
                    setupLetterWordTimeouts();
                }
            }
        }

        let paddleState = {
            ditCurrentlyPressed: false,
            dahCurrentlyPressed: false,
            ditPressedDuringElement: false,
            dahPressedDuringElement: false,
            squeezeCurrentlyPressed: false,
            squeezePressedDuringElement: false
        };

        function handlePaddlePress(side, isPressed) {
            if (overlayActive) return;
            const paddle = document.getElementById(side + '-paddle');
            
            if (isPressed) {
                paddle.classList.add('pressed');
                if (side === 'left') {
                    if (settings.polarity === 'normal') {
                        paddleState.ditCurrentlyPressed = true;
                        if (morseState.isTransmitting || morseState.iambicScheduled) {
                            paddleState.ditPressedDuringElement = true;
                        }
                    } else {
                        paddleState.dahCurrentlyPressed = true;
                        if (morseState.isTransmitting || morseState.iambicScheduled) {
                            paddleState.dahPressedDuringElement = true;
                        }
                    }
                } else {
                    if (settings.polarity === 'normal') {
                        paddleState.dahCurrentlyPressed = true;
                        if (morseState.isTransmitting || morseState.iambicScheduled) {
                            paddleState.dahPressedDuringElement = true;
                        }
                    } else {
                        paddleState.ditCurrentlyPressed = true;
                        if (morseState.isTransmitting || morseState.iambicScheduled) {
                            paddleState.ditPressedDuringElement = true;
                        }
                    }
                }
            } else {
                paddle.classList.remove('pressed');
                if (side === 'left') {
                    if (settings.polarity === 'normal') {
                        paddleState.ditCurrentlyPressed = false;
                    } else {
                        paddleState.dahCurrentlyPressed = false;
                    }
                } else {
                    if (settings.polarity === 'normal') {
                        paddleState.dahCurrentlyPressed = false;
                    } else {
                        paddleState.ditCurrentlyPressed = false;
                    }
                }
            }
            
            // Update squeeze state
            paddleState.squeezeCurrentlyPressed = paddleState.ditCurrentlyPressed && paddleState.dahCurrentlyPressed;
            if (paddleState.squeezeCurrentlyPressed && morseState.isTransmitting) {
                paddleState.squeezePressedDuringElement = true;
            }

            if (settings.mode === 'straight') {
                handleStraightKey(isPressed && side === 'left');
            } else {
                // Trigger iambic logic when paddle is pressed
                if (isPressed && !morseState.isTransmitting) {
                    handleIambic();
                }
            }
        }

        function handleIambic() {
            if (morseState.isTransmitting || morseState.iambicScheduled) return;
            
            const timings = getTimings();
            clearTimingTimeouts();
            
            // Different logic for Iambic A vs Iambic B
            let ditActive, dahActive;
            
            if (settings.mode === 'iambic-a') {
                // Iambic A: only check what's currently pressed (squeeze must be held)
                squeezeActive = paddleState.squeezeCurrentlyPressed;
            } else {
                // Iambic B: check if pressed during element OR currently pressed
                squeezeActive = paddleState.squeezeCurrentlyPressed || paddleState.squeezePressedDuringElement;
            }
            ditActive = paddleState.ditCurrentlyPressed || paddleState.ditPressedDuringElement;
            dahActive = paddleState.dahCurrentlyPressed || paddleState.dahPressedDuringElement;

            // Decide what to send based on current state
            let elementToSend = '';
            
            if (squeezeActive || (
               (morseState.lastElement === '.' && paddleState.ditCurrentlyPressed && paddleState.dahPressedDuringElement) ||
               (morseState.lastElement === '-' && paddleState.dahCurrentlyPressed && paddleState.ditPressedDuringElement)
            )) {
                // Both are active (squeeze) - alternate
                elementToSend = (morseState.lastElement === '.') ? '-' : '.';
            } else if (ditActive) {
                // Only dit is active
                elementToSend = '.';
            } else if (dahActive) {
                // Only dah is active
                elementToSend = '-';
            } else {
                // Nothing to send
                if (morseState.currentCode) {
                    setupLetterWordTimeouts();
                }
                return;
            }
            
            //console.log(".C", paddleState.ditCurrentlyPressed, "-C", paddleState.dahCurrentlyPressed, "SC", paddleState.squeezeCurrentlyPressed, ".D", paddleState.ditPressedDuringElement, "-D", paddleState.dahPressedDuringElement, "SD", paddleState.squeezePressedDuringElement, "NE", elementToSend, "PR", morseState.lastElement, "TR", morseState.isTransmitting);

            // Send the element
            morseState.isTransmitting = true;
            morseState.lastElement = elementToSend;

            if (settings.mode === 'iambic-a') {
                paddleState.ditPressedDuringElement = false;
                paddleState.dahPressedDuringElement = false;
            }
            if (settings.mode === 'iambic-b') {
                if (morseState.lastElement === '.') {
                    paddleState.ditPressedDuringElement = false;
                } else {
                    paddleState.ditPressedDuringElement = paddleState.ditCurrentlyPressed;
                }
                if (morseState.lastElement === '-') {
                    paddleState.dahPressedDuringElement = false;
                } else {
                    paddleState.dahPressedDuringElement = paddleState.dahCurrentlyPressed;
                }
            }

            paddleState.squeezePressedDuringElement = paddleState.squeezeCurrentlyPressed;

            playTone();

            const duration = (elementToSend === '.') ? timings.dit : timings.dah;
            setTimeout(() => {
                stopTone();
                morseState.isTransmitting = false;
                morseState.currentCode += elementToSend;
                morseState.lastElementTime = Date.now();
                
                // Schedule next element check after element gap
                morseState.iambicScheduled = true;
                setTimeout(() => {
                    morseState.iambicScheduled = false;
                    handleIambic();
                }, timings.elementGap);
                
            }, duration);
        }

        // Setup sliders
        function setupSliders() {
            const wpmSlider = document.getElementById('wpm-slider');
            const wpmThumb = wpmSlider.querySelector('.slider-thumb');
            const wpmValue = document.getElementById('wpm-value');
            
            const volSlider = document.getElementById('vol-slider');
            const volThumb = volSlider.querySelector('.slider-thumb');
            const volValue = document.getElementById('vol-value');
            
            const toneSlider = document.getElementById('tone-slider');
            const toneThumb = toneSlider.querySelector('.slider-thumb');
            const toneValue = document.getElementById('tone-value');
            
            function updateSlider(slider, thumb, value, min, max, current, callback) {
                const percent = (current - min) / (max - min);
                thumb.style.left = (percent * 80) + 'px';
                value.textContent = current;
                
                let isDragging = false;
                
                function handleMove(clientX) {
                    const rect = slider.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    const newValue = Math.round(min + percent * (max - min));
                    
                    thumb.style.left = (percent * 80) + 'px';
                    value.textContent = newValue;
                    callback(newValue);
                }
                
                slider.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    handleMove(e.clientX);
                });
                
                slider.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    handleMove(e.touches[0].clientX);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) handleMove(e.clientX);
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        handleMove(e.touches[0].clientX);
                    }
                });
                
                document.addEventListener('mouseup', () => isDragging = false);
                document.addEventListener('touchend', () => isDragging = false);
            }
            
            updateSlider(wpmSlider, wpmThumb, wpmValue, 5, 60, settings.wpm, (value) => {
                settings.wpm = value;
                saveSettings();
            });
            
            updateSlider(volSlider, volThumb, volValue, 0, 100, settings.vol, (value) => {
                settings.vol = value;
                saveSettings();
            });
            
            updateSlider(toneSlider, toneThumb, toneValue, 400, 1200, settings.tone, (value) => {
                settings.tone = value;
                if (oscillator) {
                    oscillator.frequency.setValueAtTime(value, audioContext.currentTime);
                }
                saveSettings();
            });
        }

        // Setup mode buttons
        function setupModeButtons() {
            // Reload settings from storage first
            settings = loadSettings();
            
            const modeButtons = document.querySelectorAll('.mode-btn');
            const polarityButtons = document.querySelectorAll('.polarity-btn');
            
            // Clear all active states first
            modeButtons.forEach(b => b.classList.remove('active'));
            polarityButtons.forEach(b => b.classList.remove('active'));
          
            const buttonsContainer = document.getElementById('buttons');
            const leftPaddle = document.getElementById('left-paddle');
            const rightPaddle = document.getElementById('right-paddle');
            leftPaddle.ondragstart = () => false;
            rightPaddle.ondragstart = () => false;
            
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settings.mode = btn.dataset.mode;
                    saveSettings();
                    
                    const polarityButtons = document.querySelectorAll('.polarity-btn');
                    const polarityGroup = polarityButtons[0].closest('.control-group');

                    if (settings.mode === 'straight') {
                        polarityButtons.forEach(btn => {
                            btn.style.opacity = '0.5';
                            btn.style.pointerEvents = 'none';
                        });
                        polarityGroup.style.opacity = '0.5';
                    } else {
                        polarityButtons.forEach(btn => {
                            btn.style.opacity = '1';
                            btn.style.pointerEvents = 'auto';
                        });
                        polarityGroup.style.opacity = '1';
                    }

                    // Update button layout
                    if (settings.mode === 'straight') {
                        rightPaddle.style.display = 'none';
                        leftPaddle.classList.remove('left');
                        leftPaddle.classList.add('single');
                        leftPaddle.textContent = 'tap / click / [ / A / ← / ,';
                    } else {
                        rightPaddle.style.display = 'flex';
                        leftPaddle.classList.remove('single');
                        leftPaddle.classList.add('left');
                        leftPaddle.textContent = 'tap / click / [ / A / ← / ,';
                        rightPaddle.textContent = 'tap / click / ] / D / → / .';
                    }
                });
                
                if (btn.dataset.mode === settings.mode) {
                    btn.click();
                }

                // Set initial active state separately, after all event listeners are set
                polarityButtons.forEach(btn => {
                    if (btn.dataset.polarity === settings.polarity) {
                        btn.classList.add('active');
                    }
                });

                updatePolarityControls(); // Add this line
            });
            
            polarityButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    polarityButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settings.polarity = btn.dataset.polarity;
                    saveSettings();
                });
            });

            // Set initial active state separately, after all event listeners are set
            polarityButtons.forEach(btn => {
                if (btn.dataset.polarity === settings.polarity) {
                    btn.classList.add('active');
                }
            });
        }

        function updatePolarityControls() {
            const polarityButtons = document.querySelectorAll('.polarity-btn');
            const polarityGroup = polarityButtons[0].closest('.control-group');
            
            if (settings.mode === 'straight') {
                polarityButtons.forEach(btn => {
                    btn.style.opacity = '0.5';
                    btn.style.pointerEvents = 'none';
                });
                polarityGroup.style.opacity = '0.5';
            } else {
                polarityButtons.forEach(btn => {
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                });
                polarityGroup.style.opacity = '1';
            }
        }

        function setupTableToggle() {
            const tableBtn = document.getElementById('show-table-btn');
            const tableContainer = document.getElementById('table-container');
            const buttonsContainer = document.getElementById('buttons');
            
            function updateTableDisplay() {
                if (settings.showTable) {
                    tableBtn.classList.add('active');
                    tableContainer.classList.add('visible');
                } else {
                    tableBtn.classList.remove('active');
                    tableContainer.classList.remove('visible');
                }
            }
            
            tableBtn.addEventListener('click', () => {
                settings.showTable = !settings.showTable;
                saveSettings();
                updateTableDisplay();
            });
            
            // Set initial state
            updateTableDisplay();
        }
   
        // Setup event listeners
        function setupEventListeners() {
            const leftPaddle = document.getElementById('left-paddle');
            const rightPaddle = document.getElementById('right-paddle');

            // Track touches separately
            let touchMap = {}; // Maps touch.identifier → "left" or "right"

            // Handle touchstart for left
            leftPaddle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    touchMap[touch.identifier] = 'left';
                }
                handlePaddlePress('left', true);
            }, { passive: false });

            // Handle touchstart for right
            rightPaddle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    touchMap[touch.identifier] = 'right';
                }
                handlePaddlePress('right', true);
            }, { passive: false });

            // Handle touchend / cancel
            function handleTouchEnd(e) {
                for (const touch of e.changedTouches) {
                    const side = touchMap[touch.identifier];
                    if (side) {
                        handlePaddlePress(side, false);
                        delete touchMap[touch.identifier];
                    }
                }
            }

            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            // Mouse and keyboard listeners
            leftPaddle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (e.button === 0) { // Left click on left paddle = left paddle
                    handlePaddlePress('left', true);
                } else if (e.button === 2) { // Right click on left paddle = right paddle
                    handlePaddlePress('right', true);
                }
            });

            rightPaddle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (e.button === 0) { // Left click on right paddle = right paddle
                    handlePaddlePress('right', true);
                } else if (e.button === 2) { // Right click on right paddle = left paddle
                    handlePaddlePress('left', true);
                }
            });

            // Handle context menu events (right-click)
            leftPaddle.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            rightPaddle.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Track which paddle/button combinations are active
            let leftClickActive = false;
            let rightClickActive = false;
            let leftClickTarget = null; // which paddle was left-clicked
            let rightClickTarget = null; // which paddle was right-clicked

            document.addEventListener('mousedown', (e) => {
                const target = e.target;
                if (e.button === 0) {
                    leftClickActive = true;
                    leftClickTarget = target;
                }
                if (e.button === 2) {
                    rightClickActive = true;
                    rightClickTarget = target;
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0 && leftClickActive) {
                    leftClickActive = false;
                    // Release the paddle that was activated by left-click
                    if (leftClickTarget === leftPaddle) {
                        handlePaddlePress('left', false);
                    } else if (leftClickTarget === rightPaddle) {
                        handlePaddlePress('right', false);
                    }
                    leftClickTarget = null;
                }
                if (e.button === 2 && rightClickActive) {
                    rightClickActive = false;
                    // Release the paddle that was activated by right-click
                    if (rightClickTarget === leftPaddle) {
                        handlePaddlePress('right', false);
                    } else if (rightClickTarget === rightPaddle) {
                        handlePaddlePress('left', false);
                    }
                    rightClickTarget = null;
                }
            });

            // Prevent context menu from appearing anywhere
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                switch (e.key) {
                    case '[':
                    case 'a':
                    case 'A':
                    case ',':
                    case 'ArrowLeft':
                        e.preventDefault();
                        handlePaddlePress('left', true);
                        break;
                    case ']':
                    case 'd':
                    case 'D':
                    case '.':
                    case 'ArrowRight':
                        e.preventDefault();
                        handlePaddlePress('right', true);
                        break;
                }
                // VBand Adapter support
                if (e.key === 'Control') {
                    if (e.code === 'ControlLeft') {
                        e.preventDefault();
                        handlePaddlePress('left', true);
                    } else if (e.code === 'ControlRight') {
                        e.preventDefault();
                        handlePaddlePress('right', true);
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.key) {
                    case '[':
                    case 'a':
                    case 'A':
                    case ',':
                    case 'ArrowLeft':
                        e.preventDefault();
                        handlePaddlePress('left', false);
                        break;
                    case ']':
                    case 'd':
                    case 'D':
                    case '.':
                    case 'ArrowRight':
                        e.preventDefault();
                        handlePaddlePress('right', false);
                        break;
                }
                // VBand Adapter support
                if (e.key === 'Control') {
                    if (e.code === 'ControlLeft') {
                        e.preventDefault();
                        handlePaddlePress('left', false);
                    } else if (e.code === 'ControlRight') {
                        e.preventDefault();
                        handlePaddlePress('right', false);
                    }
                }
            });
        }

        let overlayActive = true;

        function init() {
            settings = loadSettings();

            document.getElementById('clear-output-btn').addEventListener('click', () => {
                document.getElementById('output').textContent = '';
            });

            const startOverlay = document.getElementById('start-overlay');
            
            function closeOverlay() {
                overlayActive = false;
                if (!audioInitialized) {
                    initAudio();
                }

                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                document.removeEventListener('keydown', handleOverlayKeydown);
                startOverlay.remove();
            }

            function handleOverlayKeydown(e) {
                if (e.key === 'Control' || !e.isTrusted) {
                    return;
                }
                // Close overlay on any key press
                e.preventDefault();
                e.stopImmediatePropagation();  // <-- This line stops the event from reaching other listeners
                closeOverlay();
            }
            
            // Prevent zoom on touch devices
            let lastTouchEnd = 0;

            // Prevent double-tap zoom
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
            
            // More aggressive zoom prevention
            document.addEventListener('gesturestart', function (e) {
                e.preventDefault();
            });
            
            document.addEventListener('gesturechange', function (e) {
                e.preventDefault();
            });
            
            document.addEventListener('gestureend', function (e) {
                e.preventDefault();
            });

            document.body.addEventListener('touchmove', (e) => {
                // If it's a multi-touch gesture (pinch), prevent it
                if (e.touches.length > 1) {
                    e.preventDefault();
                    return;
                }
                
                // Allow scrolling in the table container for single touch
                if (e.target.closest('.table-container')) {
                    // Let the table container handle its own scrolling
                    return;
                }
                
                // Prevent other touch moves (like pulling to refresh)
                e.preventDefault();
            }, { passive: false });

            startOverlay.addEventListener('click', closeOverlay);
            
            // Add keydown listener for overlay
            document.addEventListener('keydown', handleOverlayKeydown);

            // Prevent link clicks from triggering overlay removal
            const creditLink = document.querySelector('#credit a');
            creditLink.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            setupSliders();
            setupModeButtons();
            setupTableToggle();
            setupEventListeners();
        }

        // Start the application
        init();
    </script>
</body>
</html>
