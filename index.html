<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Morse Code Trainer</title>
    <style>
        /* Fullscreen overlay styles */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            text-align: center;
            font-size: 2.5rem;
            z-index: 9999;
            cursor: pointer;
            user-select: none;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            touch-action: manipulation;
        }

        .controls {
            padding: 10px;
            background: #2a2a2a;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
            min-height: 80px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 14px;
            font-weight: bold;
        }

        .mode-buttons {
            display: flex;
            gap: 5px;
        }

        .mode-btn, .polarity-btn {
            padding: 8px 16px;
            border: 2px solid #555;
            background: #333;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .mode-btn.active, .polarity-btn.active {
            background: #007acc;
            border-color: #007acc;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            width: 100px;
            height: 25px;
            background: #555;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
        }

        .slider-thumb {
            width: 20px;
            height: 20px;
            background: #007acc;
            border-radius: 50%;
            position: absolute;
            top: 2.5px;
            transition: left 0.1s;
            cursor: pointer;
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
        }

        .output {
            flex: 1;
            min-height: 200px;
            padding: 20px;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            line-height: 1.6;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .buttons {
            height: 400px;
            display: flex;
            background: #2a2a2a;
            user-select: none;
            touch-action: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .utility-btn {
            padding: 8px 16px;
            border: 2px solid #555;
            background: #333;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .paddle {
            flex: 1;
            border: none;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            touch-action: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            transition: background-color 0.05s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .paddle.left {
            background: #444;
            border-right: 2px solid #666;
        }

        .paddle.right {
            background: #555;
        }

        .paddle.single {
            background: #444;
            border-right: none;
        }

        .paddle:active, .paddle.pressed {
            background: #007acc !important;
        }

        .openline {
            display: block;
            font-size: 70px;
            color: #ddaa55;
            padding: 20px;
        }

        .credit {
            display: block;
            padding: 50px;
            font-size: 14px;
        }

        .credit a:link,
        .credit a:visited,
        .credit a:hover,
        .credit a:active {
          color: #9999ff;
          font-weight: bold;
        }

        .version {
            display: block;
            padding: 0px;
            font-size: 10px;
        }

        @media (max-width: 768px) {
            .controls {
                padding: 8px;
                min-height: 70px;
            }
            
            .control-group label {
                font-size: 12px;
            }
            
            .mode-btn, .polarity-btn {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .output {
                font-size: 28px;
                padding: 15px;
            }
            
            .buttons {
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <div id="start-overlay">
        <div class="openline">Morse Practice</div>
        <div class="openline">Click to start</div>
        <div class="credit" id="credit">
            Copyright (c) 2025, Luis Quesada (HB9IPH), <a href="https://www.luisquesada.com">www.luisquesada.com</a>
        </div>
        <div class="version" id="version">
            v 1.02
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Key:</label>
            <div class="mode-buttons">
                <button class="mode-btn" data-mode="straight">Straight</button>
                <button class="mode-btn" data-mode="iambic-a">Iambic A</button>
                <button class="mode-btn" data-mode="iambic-b">Iambic B</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>WPM:</label>
            <div class="slider-container">
                <div class="slider" id="wpm-slider">
                    <div class="slider-thumb"></div>
                </div>
                <div class="slider-value" id="wpm-value">15</div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Tone:</label>
            <div class="slider-container">
                <div class="slider" id="tone-slider">
                    <div class="slider-thumb"></div>
                </div>
                <div class="slider-value" id="tone-value">700</div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Polarity:</label>
            <div class="mode-buttons">
                <button class="polarity-btn" data-polarity="normal">Normal</button>
                <button class="polarity-btn" data-polarity="inverse">Inverse</button>
            </div>
        </div>

        <div class="control-group">
            <button id="clear-output-btn" class="utility-btn">Clear</button>
        </div>
    </div>
    
    <div class="output" id="output"></div>
    
    <div class="buttons" id="buttons">
        <button class="paddle left" id="left-paddle">tap or [ or A or left arrow</button>
        <button class="paddle right" id="right-paddle">tap or ] or D or right arrow</button>
    </div>

    <script>
        // Morse code table
        const MORSE_TABLE = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..',

            '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
            '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.',

            '?': '..--..', '!': '-.-.--', '.': '.-.-.-', ':': '---...', ';': '-.-.-.',
            '=': '-...-', '/': '-..-.', '@': '.--.-.', "'": '.----.', '-': '-....-',
            ',': '--..--', '"': '.-..-.', '+': '.-.-.', ' ': ' '
        };

        const REVERSE_MORSE = {};
        Object.keys(MORSE_TABLE).forEach(key => {
            REVERSE_MORSE[MORSE_TABLE[key]] = key;
        });

        // Settings persistence
        function loadSettings() {
            try {
                const saved = localStorage.getItem('morseTrainerSettings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    console.log('Loaded settings:', parsed); // Debug line
                    return {
                        mode: parsed.mode || 'iambic-b',
                        wpm: parsed.wpm || 15,
                        tone: parsed.tone || 700,
                        polarity: parsed.polarity || 'normal'
                    };
                }
            } catch (e) {
                console.log('Could not load settings:', e);
            }
            console.log('Using default settings'); // Debug line
            return {
                mode: 'iambic-b',
                wpm: 15,
                tone: 700,
                polarity: 'normal'
            };
        }

        function saveSettings() {
            try {
                localStorage.setItem('morseTrainerSettings', JSON.stringify(settings));
            } catch (e) {
                console.log('Could not save settings:', e);
            }
        }

        // Application state
        let settings = loadSettings();

        let morseState = {
            currentCode: '',
            lastElementTime: 0,
            isTransmitting: false,
            leftPressed: false,
            rightPressed: false,
            lastElement: '',
            pendingElement: '',
            elementQueue: [],
            letterTimeout: null,
            wordTimeout: null,
            elementStartTime: 0
        };

        // Audio context and oscillator
        let audioContext;
        let oscillator;
        let gainNode;
        let filterNode;
        let audioInitialized = false;
        let audioReady = false;
        const TONE_GAIN = 0.5;
        const FLOOR_GAIN = 0.00001;
        const ENV_TIME = 0.05; // Increased to 50ms for smoother transitions

        function initAudio() {
            if (audioInitialized) return;
            audioInitialized = true;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Gain node with quiet floor
                gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(FLOOR_GAIN, audioContext.currentTime);
                
                // Optional: high-pass filter to reduce low-freq pops/clicks
                filterNode = audioContext.createBiquadFilter();
                filterNode.type = "highpass";
                filterNode.frequency.setValueAtTime(200, audioContext.currentTime);
                filterNode.Q.value = 0.707;
                
                // Connect chain: oscillator → gain → filter → speakers
                gainNode.connect(filterNode);
                filterNode.connect(audioContext.destination);
                
                // Start persistent oscillator
                oscillator = audioContext.createOscillator();
                oscillator.type = "sine";
                oscillator.frequency.setValueAtTime(settings.tone, audioContext.currentTime);
                oscillator.connect(gainNode);
                oscillator.start();
                
                audioReady = true;
            } catch (e) {
                console.error("Audio init failed:", e);
            }
        }

        function playTone() {
            if (!audioContext || !gainNode || !audioReady) return;
            
            const now = audioContext.currentTime;
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            // Use linear ramp for fade-in
            gainNode.gain.linearRampToValueAtTime(TONE_GAIN, now + ENV_TIME);
        }

        function stopTone() {
            if (!audioContext || !gainNode || !audioReady) return;
            
            const now = audioContext.currentTime;
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            // Use linear ramp for fade-out - this is the key change
            gainNode.gain.linearRampToValueAtTime(FLOOR_GAIN, now + ENV_TIME);
        }

        // Alternative version with setTargetAtTime for even smoother fade-out
        function stopToneSmooth() {
            if (!audioContext || !gainNode || !audioReady) return;
            
            const now = audioContext.currentTime;
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            // Use setTargetAtTime with fast time constant for smooth fade
            gainNode.gain.setTargetAtTime(FLOOR_GAIN, now, 0.015); // 15ms time constant
        }

        // Get timing values based on WPM
        function getTimings() {
            const ditLength = 1200 / settings.wpm; // milliseconds
            return {
                dit: ditLength,
                dah: ditLength * 3,
                elementGap: ditLength,
                letterGap: ditLength * 3,
                wordGap: ditLength * 7
            };
        }

        // Output text to display
        function outputText(text) {
            const output = document.getElementById('output');
            output.textContent += text;
            output.scrollTop = output.scrollHeight;
        }

        // Process morse code and reset state
        function processMorseCode(code) {
            if (code === '') return;
            
            const char = REVERSE_MORSE[code];
            if (char !== undefined) {
                outputText(char);
            } else {
                outputText('[?]');
            }
            
            // Reset the current code after processing
            morseState.currentCode = '';
            morseState.lastElementTime = Date.now();
        }

        // Clear existing timeouts
        function clearTimingTimeouts() {
            if (morseState.letterTimeout) {
                clearTimeout(morseState.letterTimeout);
                morseState.letterTimeout = null;
            }
            if (morseState.wordTimeout) {
                clearTimeout(morseState.wordTimeout);
                morseState.wordTimeout = null;
            }
        }

        // Set up letter/word detection timeouts
        function setupLetterWordTimeouts() {
            clearTimingTimeouts();
            const timings = getTimings();
            const now = Date.now();
            
            // Letter timeout (shorter)
            morseState.letterTimeout = setTimeout(() => {
                if (morseState.currentCode && !morseState.isTransmitting) {
                    processMorseCode(morseState.currentCode);
                    // After processing letter, set up word timeout
                    morseState.wordTimeout = setTimeout(() => {
                        if (!morseState.isTransmitting && !morseState.currentCode) {
                            outputText(' ');
                        }
                    }, timings.wordGap - timings.letterGap);
                }
            }, timings.letterGap);
        }

        // Handle element timing for straight key
        function handleStraightKey(isPressed) {
            const now = Date.now();
            const timings = getTimings();
            
            if (isPressed) {
                // Clear any pending timeouts when new transmission starts
                clearTimingTimeouts();
                
                if (!morseState.isTransmitting) {
                    morseState.isTransmitting = true;
                    morseState.lastElementTime = now;
                    playTone();
                }
            } else {
                if (morseState.isTransmitting) {
                    morseState.isTransmitting = false;
                    stopTone();
                    
                    const duration = now - morseState.lastElementTime;
                    const element = duration < (timings.dit + timings.dah) / 2 ? '.' : '-';
                    morseState.currentCode += element;
                    morseState.lastElementTime = now;
                    
                    // Set up timeouts for letter/word detection
                    setupLetterWordTimeouts();
                }
            }
        }

        function handleIambic() {
            const timings = getTimings();
            const now = Date.now();

            // Don't interrupt current transmission - let it complete
            if (morseState.isTransmitting) {
                return;
            }

            // Clear timeouts when starting new transmission
            if (morseState.leftPressed || morseState.rightPressed || morseState.pendingElement) {
                clearTimingTimeouts();
            }

            const timeSinceLastElement = now - morseState.lastElementTime;

            // Always enforce inter-element gap before sending next tone
            if (morseState.lastElementTime && timeSinceLastElement < timings.elementGap) {
                const remainingGap = timings.elementGap - timeSinceLastElement;
                setTimeout(handleIambic, remainingGap);
                return;
            }

            // Handle pending element from squeeze
            if (morseState.pendingElement) {
                transmitElement(morseState.pendingElement);
                morseState.pendingElement = '';
                return;
            }

            if (!morseState.leftPressed && !morseState.rightPressed) {
                if (morseState.currentCode) {
                    setupLetterWordTimeouts();
                }
                return;
            }

            // Determine next element
            let nextElement = '';
            if (morseState.leftPressed && morseState.rightPressed) {
                if (morseState.lastElement === '.') {
                    nextElement = '-';
                    morseState.pendingElement = '.';
                } else if (morseState.lastElement === '-') {
                    nextElement = '.';
                    morseState.pendingElement = '-';
                } else {
                    nextElement = settings.polarity === 'normal' ? '.' : '-';
                    morseState.pendingElement = settings.polarity === 'normal' ? '-' : '.';
                }
            } else if (morseState.leftPressed) {
                nextElement = settings.polarity === 'normal' ? '.' : '-';
            } else if (morseState.rightPressed) {
                nextElement = settings.polarity === 'normal' ? '-' : '.';
            }

            if (nextElement) {
                transmitElement(nextElement);
            }
        }

        function transmitElement(element) {
            const timings = getTimings();
            morseState.isTransmitting = true;
            morseState.lastElement = element;
            morseState.elementStartTime = Date.now();
            playTone();

            const duration = element === '.' ? timings.dit : timings.dah;

            setTimeout(() => {
                stopTone();
                morseState.isTransmitting = false;
                morseState.currentCode += element;
                morseState.lastElementTime = Date.now();

                setTimeout(() => {
                    if (
                        settings.mode === 'iambic-b' ||
                        (settings.mode === 'iambic-a' && morseState.leftPressed && morseState.rightPressed)
                    ) {
                        handleIambic();
                    } else {
                        if (morseState.currentCode) {
                            setupLetterWordTimeouts();
                        }
                    }
                }, timings.elementGap);
            }, duration);
        }

        // Handle paddle press
        function handlePaddlePress(side, isPressed) {
            const paddle = document.getElementById(side + '-paddle');
            if (isPressed) {
                paddle.classList.add('pressed');
                if (side === 'left') {
                    morseState.leftPressed = true;
                } else {
                    morseState.rightPressed = true;
                }
                
                // For both Iambic A and B: detect squeeze when second paddle is pressed
                if (settings.mode !== 'straight' && morseState.leftPressed && morseState.rightPressed) {
                    // Only set pending element if we don't already have one
                    if (!morseState.pendingElement) {
                        if (morseState.isTransmitting) {
                            // Currently transmitting - queue the opposite of what's being sent
                            if (morseState.lastElement === '.') {
                                morseState.pendingElement = '-';
                            } else if (morseState.lastElement === '-') {
                                morseState.pendingElement = '.';
                            }
                        } else {
                            // Not transmitting yet - queue the opposite of what will be sent first
                            const firstElement = settings.polarity === 'normal' ? '.' : '-';
                            morseState.pendingElement = settings.polarity === 'normal' ? '-' : '.';
                        }
                    }
                }
            } else {
                paddle.classList.remove('pressed');
                if (side === 'left') {
                    morseState.leftPressed = false;
                } else {
                    morseState.rightPressed = false;
                }
            }
            
            if (settings.mode === 'straight') {
                handleStraightKey(isPressed && side === 'left');
            } else {
                // For iambic modes, start transmission when paddle pressed
                if (isPressed) {
                    setTimeout(() => handleIambic(), 0); // Allow stack to clear
                }
            }
        }
        
        // Setup sliders
        function setupSliders() {
            const wpmSlider = document.getElementById('wpm-slider');
            const wpmThumb = wpmSlider.querySelector('.slider-thumb');
            const wpmValue = document.getElementById('wpm-value');
            
            const toneSlider = document.getElementById('tone-slider');
            const toneThumb = toneSlider.querySelector('.slider-thumb');
            const toneValue = document.getElementById('tone-value');
            
            function updateSlider(slider, thumb, value, min, max, current, callback) {
                const percent = (current - min) / (max - min);
                thumb.style.left = (percent * 80) + 'px';
                value.textContent = current;
                
                let isDragging = false;
                
                function handleMove(clientX) {
                    const rect = slider.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    const newValue = Math.round(min + percent * (max - min));
                    
                    thumb.style.left = (percent * 80) + 'px';
                    value.textContent = newValue;
                    callback(newValue);
                }
                
                slider.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    handleMove(e.clientX);
                });
                
                slider.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    handleMove(e.touches[0].clientX);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) handleMove(e.clientX);
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        handleMove(e.touches[0].clientX);
                    }
                });
                
                document.addEventListener('mouseup', () => isDragging = false);
                document.addEventListener('touchend', () => isDragging = false);
            }
            
            updateSlider(wpmSlider, wpmThumb, wpmValue, 5, 60, settings.wpm, (value) => {
                settings.wpm = value;
                saveSettings();
            });
            
            updateSlider(toneSlider, toneThumb, toneValue, 400, 1200, settings.tone, (value) => {
                settings.tone = value;
                if (oscillator) {
                    oscillator.frequency.setValueAtTime(value, audioContext.currentTime);
                }
                saveSettings();
            });
        }

        // Setup mode buttons
        function setupModeButtons() {
            // Reload settings from storage first
            settings = loadSettings();
            
            const modeButtons = document.querySelectorAll('.mode-btn');
            const polarityButtons = document.querySelectorAll('.polarity-btn');
            
            // Clear all active states first
            modeButtons.forEach(b => b.classList.remove('active'));
            polarityButtons.forEach(b => b.classList.remove('active'));
          
            const buttonsContainer = document.getElementById('buttons');
            const leftPaddle = document.getElementById('left-paddle');
            const rightPaddle = document.getElementById('right-paddle');
            leftPaddle.ondragstart = () => false;
            rightPaddle.ondragstart = () => false;
            
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    modeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settings.mode = btn.dataset.mode;
                    saveSettings();
                    
                    const polarityButtons = document.querySelectorAll('.polarity-btn');
                    const polarityGroup = polarityButtons[0].closest('.control-group');

                    if (settings.mode === 'straight') {
                        polarityButtons.forEach(btn => {
                            btn.style.opacity = '0.5';
                            btn.style.pointerEvents = 'none';
                        });
                        polarityGroup.style.opacity = '0.5';
                    } else {
                        polarityButtons.forEach(btn => {
                            btn.style.opacity = '1';
                            btn.style.pointerEvents = 'auto';
                        });
                        polarityGroup.style.opacity = '1';
                    }

                    // Update button layout
                    if (settings.mode === 'straight') {
                        rightPaddle.style.display = 'none';
                        leftPaddle.classList.remove('left');
                        leftPaddle.classList.add('single');
                        leftPaddle.textContent = 'tap or [ or A or left arrow';
                    } else {
                        rightPaddle.style.display = 'flex';
                        leftPaddle.classList.remove('single');
                        leftPaddle.classList.add('left');
                        leftPaddle.textContent = 'tap or [ or A or left arrow';
                        rightPaddle.textContent = 'tap or ] or D or right arrow';
                    }
                });
                
                if (btn.dataset.mode === settings.mode) {
                    btn.click();
                }

                // Set initial active state separately, after all event listeners are set
                polarityButtons.forEach(btn => {
                    if (btn.dataset.polarity === settings.polarity) {
                        btn.classList.add('active');
                    }
                });

                updatePolarityControls(); // Add this line
            });
            
            polarityButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    polarityButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    settings.polarity = btn.dataset.polarity;
                    saveSettings();
                });
            });

            // Set initial active state separately, after all event listeners are set
            polarityButtons.forEach(btn => {
                if (btn.dataset.polarity === settings.polarity) {
                    btn.classList.add('active');
                }
            });
        }

        function updatePolarityControls() {
            const polarityButtons = document.querySelectorAll('.polarity-btn');
            const polarityGroup = polarityButtons[0].closest('.control-group');
            
            if (settings.mode === 'straight') {
                polarityButtons.forEach(btn => {
                    btn.style.opacity = '0.5';
                    btn.style.pointerEvents = 'none';
                });
                polarityGroup.style.opacity = '0.5';
            } else {
                polarityButtons.forEach(btn => {
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                });
                polarityGroup.style.opacity = '1';
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            const leftPaddle = document.getElementById('left-paddle');
            const rightPaddle = document.getElementById('right-paddle');

            // Track touches separately
            let touchMap = {}; // Maps touch.identifier → "left" or "right"

            // Handle touchstart for left
            leftPaddle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    touchMap[touch.identifier] = 'left';
                }
                handlePaddlePress('left', true);
            }, { passive: false });

            // Handle touchstart for right
            rightPaddle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    touchMap[touch.identifier] = 'right';
                }
                handlePaddlePress('right', true);
            }, { passive: false });

            // Handle touchend / cancel
            function handleTouchEnd(e) {
                for (const touch of e.changedTouches) {
                    const side = touchMap[touch.identifier];
                    if (side) {
                        handlePaddlePress(side, false);
                        delete touchMap[touch.identifier];
                    }
                }
            }

            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

            // Mouse and keyboard listeners remain unchanged...
            leftPaddle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                handlePaddlePress('left', true);
            });

            rightPaddle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                handlePaddlePress('right', true);
            });

            document.addEventListener('mouseup', () => {
                handlePaddlePress('left', false);
                handlePaddlePress('right', false);
            });

            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                switch (e.key) {
                    case '[':
                    case 'a':
                    case 'A':
                    case 'ArrowLeft':
                        e.preventDefault();
                        handlePaddlePress('left', true);
                        break;
                    case ']':
                    case 'd':
                    case 'D':
                    case 'ArrowRight':
                        e.preventDefault();
                        handlePaddlePress('right', true);
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.key) {
                    case '[':
                    case 'a':
                    case 'A':
                    case 'ArrowLeft':
                        e.preventDefault();
                        handlePaddlePress('left', false);
                        break;
                    case ']':
                    case 'd':
                    case 'D':
                    case 'ArrowRight':
                        e.preventDefault();
                        handlePaddlePress('right', false);
                        break;
                }
            });
        }

        function init() {
            settings = loadSettings();

            document.getElementById('clear-output-btn').addEventListener('click', () => {
                document.getElementById('output').textContent = '';
            });

            const startOverlay = document.getElementById('start-overlay');
            
            function closeOverlay() {
                if (!audioInitialized) {
                    initAudio();
                }

                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                document.removeEventListener('keydown', handleOverlayKeydown);
                startOverlay.remove();
            }

            function handleOverlayKeydown(e) {
                // Close overlay on any key press
                e.preventDefault();
                e.stopImmediatePropagation();  // <-- This line stops the event from reaching other listeners
                closeOverlay();
            }
            
            document.body.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });

            startOverlay.addEventListener('click', closeOverlay);
            
            // Add keydown listener for overlay
            document.addEventListener('keydown', handleOverlayKeydown);

            // Prevent link clicks from triggering overlay removal
            const creditLink = document.querySelector('#credit a');
            creditLink.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            setupSliders();
            setupModeButtons();
            setupEventListeners();
        }

        // Start the application
        init();
    </script>
</body>
</html>
